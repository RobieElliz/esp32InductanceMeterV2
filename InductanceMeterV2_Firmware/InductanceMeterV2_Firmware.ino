#include <U8g2lib.h>
#include <Wire.h>
#include <esp_sleep.h>

// OLED configuration
U8G2_SSD1309_128X64_NONAME0_F_HW_I2C u8g2(U8G2_R0);

// Define pins
const int PIN_OUT = 27;    // ESP32 output pin to your circuit
const int PIN_IN = 25;     // ESP32 input pin from comparator/op-amp
const int BUTTON_PIN = 26; // Button to toggle sleep mode
const int LED_PIN = 2;     // LED to indicate measurement in progress
const int TOUCH_PIN = 4;    // ESP32 touch pin (GPIO4)
const int OUTPUT_PIN = 5;   // Output pin to change state on touch
String capacitance = "100nF";


// Mode state
String mode = "Continuous"; // Current mode: "Continuous" or "Single"

// Define second touch pin
const int TOUCH_PIN2 = 33;    // ESP32 touch pin (GPIO33)

// Define third touch pin
const int TOUCH_PIN3 = 32;    // ESP32 touch pin (GPIO32)

// Debounce parameters for TOUCH_PIN3
bool lastTouchState3 = false;    // Tracks the previous touch state for TOUCH_PIN3
unsigned long lastDebounceTime3 = 0; // Tracks the last debounce time for TOUCH_PIN3

// Debounce variables for BUTTON_PIN
bool lastButtonState = HIGH;                // Tracks the previous button state (HIGH = not pressed)
unsigned long lastButtonDebounceTime = 0;   // Tracks the last debounce time for BUTTON_PIN


// Flag to indicate if a single measurement has been done in Single Mode
bool singleMeasurementDone = false;


const int NUM_SAMPLES = 10;
const float DIFF_RATIO = 0.05f;


// Capacitor value (in Farads)
float CAPACITOR_VALUE = 100e-9; // 100nF

//Voltage Read Inputs
const int ANALOG_PIN = 34;          // Analog input pin
const float ADC_RESOLUTION = 4095; // ESP32 ADC resolution (12-bit)
const float VREF = 3.3;            // Reference voltage for ADC in volts
const float R1 = 40000.0;          // Resistor R1 in ohms
const float R2 = 50000.0;          // Resistor R2 in ohms
// Variables for long press detection
unsigned long buttonPressStartTime = 0; // Time when button was pressed
bool buttonHeld = false;                // Flag to indicate if button is held
const unsigned long LONG_PRESS_DURATION = 3000; // 3 seconds

// Battery voltage thresholds (in volts)
const float BATTERY_FULL = 4.2;
const float BATTERY_EMPTY = 3.0;

// Hysteresis threshold for transitions
const float HYSTERESIS = 0.05; // 0.05V tolerance

// Touch threshold (adjust based on your setup)
const int TOUCH_THRESHOLD = 40; // Lower values detect lighter touches

// Debounce parameters
const unsigned long DEBOUNCE_DELAY = 200; // 200 ms debounce

// Debounce parameters for TOUCH_PIN2
bool lastTouchState2 = false;    // Tracks the previous touch state for TOUCH_PIN2
unsigned long lastDebounceTime2 = 0; // Tracks the last debounce time for TOUCH_PIN2

// Variables for touch handling
bool lastTouchState = false;    // Tracks the previous touch state
bool outputState = false;       // Tracks the current state of OUTPUT_PIN
unsigned long lastDebounceTime = 0; // Tracks the last time a touch was detected

// Global variables to store measurement results
bool validMeasurement = false;
float frequency = 0.0;      // Frequency in Hz
float inductance = 0.0;     // Inductance in Henry
float inductanceu = 0.0;    // Inductance in microHenries

static const unsigned char image_logo_bits[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x80,0x07,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0xe1,0x0f,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xf1,0x1f,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xf3,0x9f,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0xf3,0x9c,0xe7,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0xf3,0x9c,0xe7,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0xf3,0x9c,0xe7,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x03,0x1c,0xe0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x03,0x1c,0xe0,0x01,0x07,0x00,0x70,0x00,0x00,0xe0,0x00,0x00,0x00,0x78,0xce,0xe7,0x1f,0xef,0xc7,0x9f,0xff,0xf1,0xe0,0x70,0xf8,0xf3,0x1f,0x00,0x78,0xde,0xe7,0x3f,0xef,0xe7,0xbf,0xff,0xf9,0xe0,0x71,0xfc,0xf7,0x1f,0x00,0x78,0xfe,0xe7,0x7c,0xef,0xf7,0x19,0x1c,0xf8,0xe1,0x73,0x9e,0x73,0x00,0x00,0x78,0xfe,0xe7,0x7c,0xef,0xf7,0x00,0x1c,0xf8,0xe1,0x77,0x0e,0x71,0x00,0x00,0x78,0xfe,0xe7,0x7c,0xef,0x77,0x00,0x1c,0xdc,0xe1,0x7f,0x0e,0xf0,0x0f,0x00,0x78,0xfe,0xe7,0x7c,0xef,0x77,0x00,0x1c,0xdc,0xe3,0x7f,0x0e,0xf0,0x0f,0x00,0x78,0xee,0xe7,0x7c,0xef,0xf7,0x00,0x1c,0xfe,0xe3,0x7e,0x0e,0x71,0x00,0x00,0x78,0xce,0xe7,0x3f,0xfe,0xe3,0x3d,0x1c,0xfe,0xe7,0x7c,0xbe,0x73,0x00,0x00,0x78,0xce,0xe7,0x3f,0xfe,0xe3,0x3f,0x1c,0x0f,0xe7,0x78,0xfc,0xf7,0x1f,0x00,0x78,0xce,0xe7,0x1f,0xfc,0xc1,0x1f,0x1c,0x07,0xe7,0x70,0xf8,0xf3,0x1f,0x00,0x00,0xc0,0x03,0x1c,0xe0,0x01,0x02,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0xc0,0x03,0x1c,0xe0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0xf3,0x9c,0xe7,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0xf3,0x9c,0xe7,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xce,0x7f,0xfc,0xe7,0x61,0x00,0xe1,0x3f,0xff,0xe3,0x1f,0xfe,0x00,0x00,0x00,0x8e,0x7f,0xfc,0xe3,0x61,0x80,0x21,0x00,0x10,0x20,0x00,0x02,0x03,0x00,0x00,0x0e,0x3f,0xf8,0xe1,0xa1,0xc0,0x21,0x00,0x10,0x20,0x00,0x02,0x02,0x00,0x00,0x0e,0x0c,0xe0,0xe0,0xa1,0x41,0x21,0x00,0x10,0x20,0x00,0x02,0x02,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x21,0x21,0x00,0x10,0x20,0x00,0x02,0x02,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x32,0x21,0x00,0x10,0x20,0x00,0x02,0x03,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x16,0xe1,0x1f,0x10,0xe0,0x1f,0xfe,0x01,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x0c,0x21,0x00,0x10,0x20,0x00,0x42,0x00,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x00,0x21,0x00,0x10,0x20,0x00,0xc2,0x00,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x00,0x21,0x00,0x10,0x20,0x00,0x82,0x01,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x00,0x21,0x00,0x10,0x20,0x00,0x02,0x01,0x00,0x00,0x0e,0x00,0x00,0xe0,0x21,0x00,0xe1,0x3f,0x10,0xe0,0x3f,0x02,0x02,0x00,0x00,0x0e,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_battery_full_bits[] = {0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x68,0xdb,0xb6,0x6e,0xdb,0xb6,0x61,0xdb,0xb6,0x61,0xdb,0xb6,0x61,0xdb,0xb6,0x61,0xdb,0xb6,0x61,0xdb,0xb6,0x6e,0xdb,0xb6,0x68,0xdb,0xb6,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_battery_83_bits[] = {0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x08,0xdb,0xb6,0x0e,0xdb,0xb6,0x01,0xdb,0xb6,0x01,0xdb,0xb6,0x01,0xdb,0xb6,0x01,0xdb,0xb6,0x01,0xdb,0xb6,0x0e,0xdb,0xb6,0x08,0xdb,0xb6,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_battery_67_bits[] = {0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x08,0xd8,0xb6,0x0e,0xd8,0xb6,0x01,0xd8,0xb6,0x01,0xd8,0xb6,0x01,0xd8,0xb6,0x01,0xd8,0xb6,0x01,0xd8,0xb6,0x0e,0xd8,0xb6,0x08,0xd8,0xb6,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_battery_50_bits[] = {0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x08,0xc0,0xb6,0x0e,0xc0,0xb6,0x01,0xc0,0xb6,0x01,0xc0,0xb6,0x01,0xc0,0xb6,0x01,0xc0,0xb6,0x01,0xc0,0xb6,0x0e,0xc0,0xb6,0x08,0xc0,0xb6,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_battery_33_bits[] = {0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x08,0x00,0xb6,0x0e,0x00,0xb6,0x01,0x00,0xb6,0x01,0x00,0xb6,0x01,0x00,0xb6,0x01,0x00,0xb6,0x01,0x00,0xb6,0x0e,0x00,0xb6,0x08,0x00,0xb6,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_battery_17_bits[] = {0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x08,0x00,0xb0,0x0e,0x00,0xb0,0x01,0x00,0xb0,0x01,0x00,0xb0,0x01,0x00,0xb0,0x01,0x00,0xb0,0x01,0x00,0xb0,0x0e,0x00,0xb0,0x08,0x00,0xb0,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_battery_0_bits[] = {0x00,0x00,0x00,0xf0,0xff,0x7f,0x08,0x00,0x80,0x08,0x02,0x82,0x0e,0x04,0x81,0x01,0x88,0x80,0x01,0x50,0x80,0x01,0x20,0x80,0x01,0x50,0x80,0x01,0x88,0x80,0x0e,0x04,0x81,0x08,0x02,0x82,0x08,0x00,0x80,0xf0,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_dolph_cry_bits[] = {0x00,0x00,0xf0,0x7f,0x00,0x00,0x00,0x00,0x00,0x0e,0x80,0x03,0x00,0x00,0x00,0x80,0x01,0x00,0x0c,0x00,0x00,0x00,0x60,0x00,0x00,0x30,0x00,0x00,0x00,0x10,0x00,0x00,0x40,0x00,0x00,0x00,0x08,0x00,0x00,0x80,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x08,0x00,0x80,0x00,0x00,0x00,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x00,0x10,0x00,0x40,0x00,0x00,0x00,0x00,0x10,0x00,0x20,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x00,0x00,0x20,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x00,0x10,0x00,0x00,0x00,0x00,0x40,0x00,0x10,0x00,0x00,0x20,0x00,0x40,0x00,0x08,0x00,0x00,0x1e,0x00,0x44,0x00,0x08,0x00,0x00,0x00,0x00,0x58,0x00,0x08,0x00,0x00,0x00,0x00,0x40,0x00,0x08,0x00,0x07,0x00,0x00,0x40,0x00,0x04,0x00,0x1f,0x00,0x00,0x40,0x00,0x04,0x00,0xff,0x07,0x00,0x66,0x00,0x04,0x80,0xff,0x07,0x00,0x7e,0x00,0x04,0x40,0xfd,0x07,0x00,0x7e,0x00,0x04,0x20,0xf9,0x01,0x70,0x7c,0x00,0x04,0x90,0x00,0x00,0x81,0x38,0x00,0x04,0x90,0x00,0x40,0x00,0x21,0x00,0x02,0x90,0x00,0x00,0x00,0x22,0x00,0x02,0x60,0x00,0x00,0x00,0x24,0x00,0x02,0x00,0x00,0x00,0x00,0x28,0x00,0x02,0x00,0x00,0x00,0x00,0x30,0x00,0x02,0x00,0x00,0x1e,0x00,0x60,0x00,0x02,0x00,0x00,0xe1,0x00,0xc0,0x00,0x02,0x00,0x08,0x00,0x03,0x80,0x00,0x01,0x00,0x08,0x00,0x0c,0x00,0x01,0x01,0x00,0x10,0x00,0x10,0x00,0x01,0x01,0x00,0x00,0x00,0x60,0x00,0x01,0x01,0x00,0x00,0x18,0x80,0x01,0x01,0x01,0x00,0x00,0x78,0x00,0xfe,0x00,0x01,0x00,0x00,0xf0,0x01,0x80,0x00,0x00,0x00,0x00,0xe0,0x0f,0x40,0x00,0x00,0x00,0x00,0xc0,0x7f,0x20,0x00,0x00,0x00,0x00,0x80,0xff,0x1f,0x00,0x00,0x00,0x00,0x00,0xff,0x0f,0x00,0x00,0x00,0x00,0x00,0xfe,0x07,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0xc0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00};
static const unsigned char image_cross_small_bits[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x86,0x01,0xcc,0x00,0x78,0x00,0x30,0x00,0x78,0x00,0xcc,0x00,0x86,0x01,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_hour_glass_75_bits[] = {0xff,0x07,0x02,0x02,0x02,0x02,0x8a,0x02,0xfa,0x02,0x74,0x01,0xa8,0x00,0x50,0x00,0x50,0x00,0x88,0x00,0x24,0x01,0x22,0x02,0x72,0x02,0xfa,0x02,0xfe,0x03,0xff,0x07};
// New Image: Dolphin Common
static const unsigned char image_DolphinCommon_bits[] = {
  0x00,0x00,0x00,0x00,0xff,0x07,0x00,0x00,0x00,0x00,0xe0,0x01,0x3c,0x00,0x00,0x00,
  0x00,0x3c,0x00,0xe0,0x00,0x00,0x00,0x00,0x07,0x00,0x80,0x03,0x00,0x00,0x80,0x01,
  0x00,0x00,0x06,0x00,0x00,0xc0,0x00,0x00,0x00,0x0c,0x00,0x00,0x60,0x00,0x00,0x00,
  0x18,0x00,0x00,0x20,0x00,0x00,0x00,0x10,0x00,0x00,0x30,0x00,0x00,0x00,0x30,0x00,
  0x00,0x10,0x00,0x00,0x00,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x60,0x00,0x00,0x18,
  0x00,0x00,0x00,0x40,0x00,0x00,0x08,0x00,0x00,0x3f,0xc0,0x00,0x00,0x08,0x00,0x80,
  0x40,0x80,0x00,0x00,0x08,0x00,0x40,0xfe,0x80,0x00,0x00,0x0c,0x00,0x20,0xff,0x81,
  0x00,0x00,0x04,0x00,0xa0,0xf3,0x01,0x00,0x00,0x04,0x00,0xa0,0xf3,0x01,0xc0,0x03,
  0x04,0x00,0xa0,0xff,0x01,0x40,0x06,0x04,0x00,0xa0,0xff,0x01,0x40,0x04,0x04,0x00,
  0xa0,0xff,0x01,0x40,0x0c,0x0c,0x00,0x20,0xff,0x01,0x40,0x08,0x08,0x00,0x40,0x06,
  0x02,0x40,0x18,0xf8,0x03,0x80,0x03,0x04,0x40,0x10,0x0f,0x00,0x00,0x01,0x00,0x70,
  0xb0,0x01,0x00,0x00,0x20,0x00,0x1c,0x66,0x00,0x00,0x00,0x20,0x00,0x06,0x28,0x00,
  0x00,0x00,0x20,0x00,0x03,0x28,0x00,0x00,0x00,0x10,0x00,0x01,0x10,0x00,0x00,0x00,
  0x08,0x00,0x01,0x90,0x0f,0x00,0x00,0x06,0x00,0x01,0x50,0xf0,0x00,0xf0,0x01,0x00,
  0x05,0x28,0x00,0xff,0x0f,0x00,0x00,0x05,0x24,0x00,0x00,0x00,0x00,0x00,0x09,0x43,
  0x00,0x00,0x00,0x00,0x00,0xf3,0x80,0x01,0x00,0x00,0x00,0x06,0x80,0x0f,0x00,0x00,
  0x00,0x00,0x0c,0x80,0xf9,0x03,0x00,0x00,0x00,0x18,0x00,0x81,0xff,0x0f,0x00,0x00,
  0x10,0x00,0x81,0xff,0x07,0x00,0x00,0x10,0x00,0x81,0xff,0x03,0x00,0x00,0x10,0x00,
  0xc3,0xff,0x01,0x00,0x00,0x10,0x00,0x62,0x7d,0x00,0x00,0x00,0x18,0x00,0x32,0x01,
  0x00,0x00,0x00,0x08,0x00,0x1e,0x01,0x00,0x00,0x00,0x08,0x00,0x04,0x02,0x00,0x00,
  0x00,0x08,0x00,0x04,0x02,0x00,0x00,0x00,0x08,0x00,0x00,0x02,0x00,0x00,0x00
};
  
// Variable to track the current battery level image
const unsigned char* currentBatteryImage = image_battery_full_bits;

// Define device states
enum DeviceState {
  NORMAL,
  ABOUT
};

DeviceState currentState = NORMAL; // Initialize to NORMAL state


// Function Prototypes
void measureInductance();
void SinglemeasureInductance();
void handleTouch1(); // Handles touch on TOUCH_PIN (IO4)
void handleTouch2(); // Handles touch on TOUCH_PIN2 (IO33)
void handleTouch3(); // Handles touch on TOUCH_PIN3 (IO32)
void onToggleHigh();
void onToggleLow();
void onToggleMode(); // Actions when Mode changes
void handleButton(); // Updated to handle short and long presses
void showAboutScreen();
void resetDevice();
void wakeUpDisplay();


void formatFiveDigits(float value, char* buffer, size_t bufferSize) {
  if (value >= 1000.0) {
    // 1000 and above: no decimal places (e.g., 12345)
    snprintf(buffer, bufferSize, "%.0f", value);
  }
  else if (value >= 100.0) {
    // 100 to 999.999: two decimal places (e.g., 123.45)
    snprintf(buffer, bufferSize, "%.2f", value);
  }
  else if (value >= 10.0) {
    // 10 to 99.999: three decimal places (e.g., 12.345)
    snprintf(buffer, bufferSize, "%.3f", value);
  }
  else if (value >= 1.0) {
    // 1 to 9.9999: four decimal places (e.g., 1.2345)
    snprintf(buffer, bufferSize, "%.4f", value);
  }
  else if (value > 0.0) {
    // Below 1.0: five decimal places (e.g., 0.12345)
    snprintf(buffer, bufferSize, "%.5f", value);
  }
  else {
    // Zero: always show "0.00000"
    snprintf(buffer, bufferSize, "0.0000");
  }
}

// Function to Reset the Device
void resetDevice() {
  ESP.restart();
}


// Function to Show About Screen
void showAboutScreen() {
  u8g2.clearBuffer();
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);

  // Draw the Dolphin Common image
  u8g2.drawXBM(70, 1, 56, 48, image_DolphinCommon_bits);

  // Set font for names
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(5, 23, "Aycardo");
  u8g2.drawStr(5, 12, "Abareta");
  u8g2.drawStr(5, 35, "Fernandez");
  u8g2.drawStr(5, 46, "Morales");
  u8g2.drawStr(5, 57, "Tizon");

  // Set font for date
  u8g2.setFont(u8g2_font_t0_12b_tr);
  u8g2.drawStr(78, 59, "01-2025");

  u8g2.sendBuffer();
}

void setup() {
  Serial.begin(115200);
  pinMode(PIN_OUT, OUTPUT);
  pinMode(PIN_IN, INPUT);  
  pinMode(LED_PIN, OUTPUT);
  pinMode(OUTPUT_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP); // Use internal pull-up resistor

  // Initialize OLED display
  u8g2.begin();

  // Enable external wakeup on BUTTON_PIN (IO26) for Deep Sleep
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_26, 0); // Wake up when BUTTON_PIN (GPIO26) is LOW

  // Check wake-up reason
  esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
  if (wakeup_reason == ESP_SLEEP_WAKEUP_EXT0) {
    // Device woke up from Deep Sleep due to BUTTON_PIN press
    wakeUpDisplay();
    singleMeasurementDone = false; // Reset flag after waking up
  }

  analogReadResolution(12); // Set ADC resolution to 12 bits

  // Initialize OLED display
  u8g2.begin();

  u8g2.clearBuffer();
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);

  u8g2.drawXBM(7, 0, 114, 64, image_logo_bits);

  u8g2.sendBuffer();

  Serial.println("Inductance Meter V2");

  delay(1000);
}



// Handle Button Presses (Short and Long Press)
void handleButton() {
  int buttonState = digitalRead(BUTTON_PIN);

  if (currentState == NORMAL) {
    // Normal State: Handle short and long presses
    if (buttonState == LOW && lastButtonState == HIGH) {
      // Button Pressed
      buttonPressStartTime = millis();
      buttonHeld = false;
    }
    else if (buttonState == HIGH && lastButtonState == LOW) {
      // Button Released
      unsigned long pressDuration = millis() - buttonPressStartTime;
      if (pressDuration >= LONG_PRESS_DURATION) { // Long Press (3 seconds)
        Serial.println("Long press detected. Showing About Screen.");
        currentState = ABOUT;
        showAboutScreen();
      }
      else { // Short Press
        Serial.println("Short press detected. Entering Deep Sleep...");
        // Display "Shutting Down" before sleep
        u8g2.clearBuffer();
        u8g2.setFontMode(1);
        u8g2.setBitmapMode(1);

        u8g2.setFont(u8g2_font_6x13_tr);
        u8g2.drawStr(66, 29, "Shutting ");
        u8g2.drawStr(66, 43, "Down...");

        u8g2.drawXBM(5, 5, 49, 54, image_dolph_cry_bits);

        u8g2.sendBuffer();
        delay(1000); // Allow time for the message to be displayed

        // Enter Deep Sleep
        enterDeepSleep();
      }
    }

    // Update the last button state
    lastButtonState = buttonState;
  }
  else if (currentState == ABOUT) {
    // About State: Any button press resets the device
    if (buttonState == LOW && lastButtonState == HIGH) {
      Serial.println("Button pressed in About Screen. Resetting device.");
      resetDevice();
    }

    // Update the last button state
    lastButtonState = buttonState;
  }
}


void enterDeepSleep() {
  // Clear the OLED display before sleeping
  u8g2.clearBuffer();
  u8g2.sendBuffer();

  // Ensure all peripherals are turned off to save power
  // (Optional) Add code to turn off other peripherals if necessary

  // Enter Deep Sleep
  esp_deep_sleep_start();
}

void wakeUpDisplay() {
  // Display "Opening" message
  u8g2.clearBuffer();
u8g2.setFontMode(1);
u8g2.setBitmapMode(1);

u8g2.drawXBM(57, 12, 11, 16, image_hour_glass_75_bits);

u8g2.setFont(u8g2_font_6x10_tr);
u8g2.drawStr(29, 43, "Waking up...");

u8g2.sendBuffer();
}


void handleTouch1() {
  // Read touch value (0 to 65535)
  int touchValue = touchRead(TOUCH_PIN);

  // Determine if touch is detected based on threshold
  bool currentTouchState = (touchValue < TOUCH_THRESHOLD);

  // Check for a new touch event (transition from not touched to touched)
  if (currentTouchState && !lastTouchState) {
    // Check if enough time has passed since the last toggle (debounce)
    if (millis() - lastDebounceTime > DEBOUNCE_DELAY) {
      // Toggle the output state
      outputState = !outputState;
      digitalWrite(OUTPUT_PIN, outputState ? HIGH : LOW);

      // Debug output
      Serial.print("Touch detected on IO4. IO5 set to ");
      Serial.println(outputState ? "HIGH." : "LOW.");

      // Call the corresponding action function based on the new state
      if (outputState) {
        onToggleHigh();
      } else {
        onToggleLow();
      }

      // Update the debounce timer
      lastDebounceTime = millis();
    }
  }

  // Update the last touch state
  lastTouchState = currentTouchState;
}

/**
 * @brief Actions to perform when OUTPUT_PIN (IO5) is set to HIGH.
 *        Customize this function with additional behaviors as needed.
 */
void onToggleHigh() {
  // Add your custom actions here when IO5 is set to HIGH
  // Example: Turn on another LED, send a signal, etc.
    
  // Example action:
  // digitalWrite(ANOTHER_LED_PIN, HIGH);
CAPACITOR_VALUE = 4.925e-6; // 1uF
capacitance = "5uF";
  // Placeholder for additional actions
  Serial.println("Custom Action: IO5 is now HIGH. Execute additional tasks here.");
}

/**
 * @brief Actions to perform when OUTPUT_PIN (IO5) is set to LOW.
 *        Customize this function with additional behaviors as needed.
 */
void onToggleLow() {
  // Add your custom actions here when IO5 is set to LOW
  // Example: Turn off another LED, send a signal, etc.
  
  // Example action:
  // digitalWrite(ANOTHER_LED_PIN, LOW);
CAPACITOR_VALUE = 100e-9; // 100nF
capacitance = "100nF";
  // Placeholder for additional actions
  Serial.println("Custom Action: IO5 is now LOW. Execute additional tasks here.");
}

void handleTouch2() {
  // Read touch value (0 to 65535)
  int touchValue2 = touchRead(TOUCH_PIN2);

  // Determine if touch is detected based on threshold
  bool currentTouchState2 = (touchValue2 < TOUCH_THRESHOLD);

  // Check for a new touch event (transition from not touched to touched)
  if (currentTouchState2 && !lastTouchState2) {
    // Check if enough time has passed since the last toggle (debounce)
    if (millis() - lastDebounceTime2 > DEBOUNCE_DELAY) {
      // Toggle the mode
      if (mode == "Continuous") {
        mode = "Single";
      } else {
        mode = "Continuous";
      }

      // Debug output
      Serial.print("Touch detected on IO33. Mode set to ");
      Serial.println(mode);

      // Call the corresponding action function based on the new mode
      onToggleMode();

      // Reset singleMeasurementDone flag when mode changes
      singleMeasurementDone = false;

      // Update the debounce timer
      lastDebounceTime2 = millis();
    }
  }

  // Update the last touch state
  lastTouchState2 = currentTouchState2;
}

void onToggleMode() {
  // Add your custom actions here when Mode changes
  // Example: Change measurement mode, adjust display settings, etc.

  // Example action:
  // digitalWrite(MODE_LED_PIN, mode == "Single" ? HIGH : LOW);

  // Placeholder for additional actions
  Serial.println("Custom Action: Mode has been toggled.");
}

void handleTouch3() {
  // Read touch value (0 to 65535)
  int touchValue3 = touchRead(TOUCH_PIN3);

  // Determine if touch is detected based on threshold
  bool currentTouchState3 = (touchValue3 < TOUCH_THRESHOLD);

  // Check for a new touch event (transition from not touched to touched)
  if (currentTouchState3 && !lastTouchState3) {
    // Check if enough time has passed since the last toggle (debounce)
    if (millis() - lastDebounceTime3 > DEBOUNCE_DELAY) {
      // Only trigger measurement if in Single Mode
      if (mode == "Single") {
        // Perform single inductance measurement
        SinglemeasureInductance();
        singleMeasurementDone = true;

        // Debug output
        Serial.println("Single measurement triggered via IO32 touch.");
      }

      // Update the debounce timer
      lastDebounceTime3 = millis();
    }
  }

  // Update the last touch state
  lastTouchState3 = currentTouchState3;
}



void measureInductance() {
  // Reset measurement variables

  digitalWrite(LED_PIN, HIGH);
  validMeasurement = false;
  frequency        = 0.0;
  inductance       = 0.0;
  inductanceu      = 0.0;

  float sumHighTime = 0.0;
  float sumLowTime  = 0.0;
  int validSamples  = 0;

  // Collect multiple samples
  for (int i = 0; i < 2; i++) {
    // Excite the circuit
    digitalWrite(PIN_OUT, HIGH);
    delay(1);
    digitalWrite(PIN_OUT, LOW);
    // delayMicroseconds(5);

    // Measure pulse widths
    unsigned long highTime = pulseIn(PIN_IN, HIGH, 30000); // 500 ms timeout
    unsigned long lowTime  = pulseIn(PIN_IN, LOW,  30000); // 500 ms timeout

    // Only accept non-zero samples
    if (highTime > 0 && lowTime > 0) {
      sumHighTime += highTime;
      sumLowTime  += lowTime;
      validSamples++;
    } else {
      if (i == 0) {
        // First sample is invalid; set measurements to zero and exit early
        validMeasurement = false;
        frequency        = 0.0;
        inductance       = 0.0;
        inductanceu      = 0.0;
        Serial.println("Invalid first sample. Exiting measurement.");
        return; // Exit the function early
      }
      // For other samples, simply ignore invalid ones and continue
    }

    delay(20); // Short gap before next sample
  }

  // If any valid samples, compute average and calculate inductance
  if (validSamples > 0) {
    float avgHighTime = sumHighTime / validSamples;   // microseconds
    float avgLowTime  = sumLowTime  / validSamples;   // microseconds
    float avgPeriod   = avgHighTime + avgLowTime;     // total period in microseconds

    // Compute frequency in Hz
    frequency = 1.0e6 / avgPeriod; 

    // Compute inductance (in henries) using L = 1 / (4 * π² * f² * C)
    inductance  = 1.0 / (4.0 * M_PI * M_PI * frequency * frequency * CAPACITOR_VALUE);
    inductanceu = inductance * 1e6; // Convert to µH

    // Mark measurement as valid
    validMeasurement = true;

    // Debug output
    Serial.print("Frequency (Hz): ");
    Serial.println(frequency, 2);
    Serial.print("Inductance (H): ");
    Serial.println(inductance, 6);

      digitalWrite(LED_PIN, LOW);

  }
}



void SinglemeasureInductance() {
  digitalWrite(LED_PIN, HIGH); // Turn on LED to indicate measurement in progress

  // Reset measurement variables
  validMeasurement = false;
  frequency = 0.0;
  inductance = 0.0;
  inductanceu = 0.0;

  float sumHighTime = 0.0;
  float sumLowTime  = 0.0;
  int validSamples  = 0;

  // Collect 10 samples
  for (int i = 0; i < NUM_SAMPLES; i++) {
    // Excite the circuit
    digitalWrite(PIN_OUT, HIGH);
    delay(5); // 5 milliseconds excitation
    digitalWrite(PIN_OUT, LOW);
    // delayMicroseconds(5); // 200 microseconds post-excitation

    // Measure pulse widths with a 10 ms timeout (10000 microseconds)
    unsigned long highTime = pulseIn(PIN_IN, HIGH, 10000); // 10 ms timeout
    unsigned long lowTime  = pulseIn(PIN_IN, LOW,  10000); // 10 ms timeout

    // Check if both highTime and lowTime are valid
    if (highTime > 0 && lowTime > 0) {
      // Accumulate high and low times
      sumHighTime += highTime;
      sumLowTime  += lowTime;
      validSamples++;
    } else {
      Serial.print("Invalid sample ");
      Serial.println(i + 1);
      // Optionally, you can choose to retry or handle invalid samples differently
    }

    delay(20); // Short gap before next sample
  }

  // Check if enough valid samples were collected
  if (validSamples >= NUM_SAMPLES * 0.8) { // At least 80% of samples are valid
    float avgHighTime = sumHighTime / validSamples;   // microseconds
    float avgLowTime  = sumLowTime  / validSamples;   // microseconds
    float avgPeriod   = avgHighTime + avgLowTime;     // total period in microseconds

    // Compute frequency in Hz
    frequency = 1.0e6 / avgPeriod; 

    // Compute inductance (in henries) using L = 1 / (4 * π² * f² * C)
    inductance  = 1.0 / (4.0 * M_PI * M_PI * frequency * frequency * CAPACITOR_VALUE);
    inductanceu = inductance * 1e6; // Convert to µH

    // Calculate difference ratio to ensure measurement consistency
    float diffRatio = fabs(avgHighTime - avgLowTime) / (avgHighTime + avgLowTime);
      validMeasurement = true;

    // // Validate the measurement based on difference ratio
    // if (diffRatio < DIFF_RATIO) {
    //   validMeasurement = true;

    //   // Debug output
    //   Serial.print("Average Frequency (Hz): ");
    //   Serial.println(frequency, 2);
    //   Serial.print("Average Inductance (H): ");
    //   Serial.println(inductance, 6);
    // } else {
    //   // Difference ratio too high, invalid measurement
    //   validMeasurement = false;
    //   frequency        = 0.0;
    //   inductance       = 0.0;
    //   inductanceu      = 0.0;

    //   Serial.println("Measurement diffRatio too high. Setting values to 0.");
    // }
  } else {
    // Not enough valid samples
    validMeasurement = false;
    frequency        = 0.0;
    inductance       = 0.0;
    inductanceu      = 0.0;

    Serial.println("Not enough valid samples. Setting values to 0.");
  }

  digitalWrite(LED_PIN, LOW); // Turn off LED after measurement
}

void loop() {
  // Handle button presses (short and long)
  handleButton();

    digitalWrite(LED_PIN, LOW); // Turn off LED after measurement


  // Check the current state
  if (currentState == NORMAL) {
    //////////////////////////////////////BATTERY HANDLE//////////////////////////////////////////

    // Read the raw ADC value from IO34
    int adcValue = analogRead(ANALOG_PIN);

    // Calculate the measured voltage at the ADC pin
    float voltageAtPin = (adcValue / ADC_RESOLUTION) * VREF;

    // Calculate the source voltage using the resistor network formula
    // Vsource = Vpin * (R1 + R2) / R2
    float batteryVoltage = (voltageAtPin * (R1 + R2) / R2) + 0.4;

    // Determine battery percentage
    float batteryPercentage = (batteryVoltage - BATTERY_EMPTY) / (BATTERY_FULL - BATTERY_EMPTY) * 100;
    batteryPercentage = constrain(batteryPercentage, 0, 100); // Clamp percentage between 0 and 100

    // Determine the appropriate battery image using hysteresis
    const unsigned char* newBatteryImage;
    if (batteryPercentage >= 83) {
      newBatteryImage = image_battery_full_bits;
    } else if (batteryPercentage >= 67) {
      newBatteryImage = image_battery_83_bits;
    } else if (batteryPercentage >= 50) {
      newBatteryImage = image_battery_67_bits;
    } else if (batteryPercentage >= 33) {
      newBatteryImage = image_battery_50_bits;
    } else if (batteryPercentage >= 17) {
      newBatteryImage = image_battery_33_bits;
    } else if (batteryPercentage > 0) {
      newBatteryImage = image_battery_17_bits;
    } else {
      newBatteryImage = image_battery_0_bits;
    }
    // Apply hysteresis: Change the image only if the voltage crosses the threshold by a significant margin
    if (currentBatteryImage != newBatteryImage) {
      if ((newBatteryImage == image_battery_full_bits && batteryVoltage >= (BATTERY_FULL - HYSTERESIS)) ||
          (newBatteryImage == image_battery_83_bits && batteryVoltage >= 3.9 && batteryVoltage < (BATTERY_FULL - HYSTERESIS)) ||
          (newBatteryImage == image_battery_67_bits && batteryVoltage >= 3.7 && batteryVoltage < 3.9) ||
          (newBatteryImage == image_battery_50_bits && batteryVoltage >= 3.5 && batteryVoltage < 3.7) ||
          (newBatteryImage == image_battery_33_bits && batteryVoltage >= 3.3 && batteryVoltage < 3.5) ||
          (newBatteryImage == image_battery_17_bits && batteryVoltage > BATTERY_EMPTY && batteryVoltage < 3.3) ||
          (newBatteryImage == image_battery_0_bits && batteryVoltage <= BATTERY_EMPTY)) {
        currentBatteryImage = newBatteryImage;
      }
    }

    // Handle all touch inputs
    handleTouch1(); // Handles touch on TOUCH_PIN (IO4)
    handleTouch2(); // Handles touch on TOUCH_PIN2 (IO33)
    handleTouch3(); // Handles touch on TOUCH_PIN3 (IO32)

    // Measurement Control Based on Mode
    if (mode == "Continuous") {
      measureInductance();
      singleMeasurementDone = false; // Reset flag when in Continuous mode
    } else if (mode == "Single") {
      if (singleMeasurementDone) {
        // Do nothing, keep displaying the last measurement
        // Measurement has already been done in handleTouch3()
      } else {
        // No measurement has been done, set frequency and inductance to 0
        frequency = 0.0;
        inductance = 0.0;
        inductanceu = 0.0;
      }
    }

    /// DISPLAY INFO////////////////////////////////////////////////////////////////////////

    u8g2.clearBuffer();
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);

    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(65, 59, mode.c_str());

    u8g2.drawStr(4, 59, ("C: " + capacitance).c_str());

    u8g2.setFont(u8g2_font_t0_12_tr);
    u8g2.drawStr(4, 16, "Freq:");

    // Draw lines for layout
    u8g2.drawLine(0, 47, 128, 47);
    u8g2.drawLine(58, 63, 58, 48);
    u8g2.drawLine(128, 23, 0, 23);

    // BATTERY LEVELS
    u8g2.drawXBM(98, 3, 24, 16, currentBatteryImage);

    // Prepare strings and units for display
    char inductanceStr[10]; // Buffer to store inductance as a string
    char frequencyStr[10];  // Buffer to store frequency as a string
    const char* inductanceUnit; // Pointer to store the inductance unit ("uH" or "mH")
    const char* frequencyUnit;  // Pointer to store the frequency unit ("Hz" or "kHz")
    float displayInductance;    // Adjusted inductance value for display
    float displayFrequency;     // Adjusted frequency value for display

    // --- Inductance Unit/Value ---

    // If inductanceu is in microhenries (µH):
    //  - >=1000 µH => mH
    //  - < 1.0 µH => nH
    //  - otherwise => keep in µH
    if (inductanceu >= 1000.0) {
      // convert µH to mH
      displayInductance = inductanceu / 1000.0;
      inductanceUnit = "mH";
    } else if (inductanceu < 1.0 && inductanceu > 0.0) {
      // convert µH to nH
      displayInductance = inductanceu * 1000.0;
      inductanceUnit = "nH";
    } else {
      // keep µH
      displayInductance = inductanceu;
      inductanceUnit = "uH";
    }

    // --- Frequency Unit/Value ---

    if (frequency > 999.99) {
      displayFrequency = frequency / 1000.0; // kHz
      frequencyUnit = "kHz";
    } else {
      displayFrequency = frequency; // Hz
      frequencyUnit = "Hz";
    }

    formatFiveDigits(displayInductance, inductanceStr, sizeof(inductanceStr));
    formatFiveDigits(displayFrequency, frequencyStr, sizeof(frequencyStr));

    // Now handle the drawing logic for Single vs Continuous mode
    if (mode == "Single") {
      if (!singleMeasurementDone) {
        // 1) Single mode, but no measurement has been done yet:
        //    => Show "Ready" (instead of "Error")
        u8g2.setFont(u8g2_font_t0_22b_tr);
        u8g2.drawStr(25, 43, "Ready");     // Instead of "Error"
        u8g2.setFont(u8g2_font_t0_22_tr);
        u8g2.drawStr(98, 42, "");

        // Show Frequency as "0.000 Hz"
        u8g2.setFont(u8g2_font_t0_12_tr);
        u8g2.drawStr(36, 16, "0.000");
        u8g2.drawStr(75, 16, "Hz");
      }
      else {
        // 2) Single mode, measurement was attempted (singleMeasurementDone == true)
        if (!validMeasurement) {
          // Measurement attempt returned invalid => "Error"
          u8g2.setFont(u8g2_font_t0_14b_tr);
          u8g2.drawStr(41, 40, "Pls Retry");
          u8g2.drawXBM(22, 27, 10, 16, image_cross_small_bits);

          // Clear or omit inductance unit
          u8g2.setFont(u8g2_font_t0_22_tr);
          u8g2.drawStr(98, 42, "");

          // Frequency => "0.000 Hz"
          u8g2.setFont(u8g2_font_t0_12_tr);
          u8g2.drawStr(36, 16, "0.000");
          u8g2.drawStr(75, 16, "Hz");
        }
        else {
          // 3) Single mode, valid measurement done => Show measurement
          // Inductance
          u8g2.setFont(u8g2_font_t0_22b_tr);
          u8g2.drawStr(25, 43, inductanceStr);
          u8g2.setFont(u8g2_font_t0_22_tr);
          u8g2.drawStr(98, 42, inductanceUnit);

          // Frequency
          u8g2.setFont(u8g2_font_t0_12_tr);
          u8g2.drawStr(36, 16, frequencyStr);
          u8g2.drawStr(75, 16, frequencyUnit);
        }
      }
    }
    else {
      // Continuous mode => always show measurement (or zero if not read)
      // Inductance
      u8g2.setFont(u8g2_font_t0_22b_tr);
      u8g2.drawStr(25, 43, inductanceStr);
      u8g2.setFont(u8g2_font_t0_22_tr);
      u8g2.drawStr(98, 42, inductanceUnit);

      // Frequency
      u8g2.setFont(u8g2_font_t0_12_tr);
      u8g2.drawStr(36, 16, frequencyStr);
      u8g2.drawStr(75, 16, frequencyUnit);
    }

    u8g2.sendBuffer();
  }
  else if (currentState == ABOUT) {
    // In ABOUT state, do not perform any other operations
    // The About screen is already displayed in showAboutScreen()
    // Optionally, you can add a delay or handle additional logic here
    // For now, do nothing
  }
}







